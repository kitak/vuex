しかし、単純さは、**共通の状態を共有する複数のコンポーネントを持ったときに**、あっさりと破綻します:

- 複数のビュー同士で同じ状態に依存することがあります。
- 異なるビューからのアクションは、同じ状態を変更する必要があります。

問題の一つ目は、props を渡すことは、深く入れ子になったコンポーネントに対しておこなうのは面倒で、単純に兄弟コンポーネントでは単純に動きません。問題の二つ目は、直接親子のインスタンスを参照したり、イベントを介して複数の状態のコピーを変更したり、同期することを試みるソリューションに頼っていることがよくあります。これらのパターンは、いずれも脆く、すぐにメンテナンスが困難なコードに繋がります。

では、コンポーネントから共有している状態を抽出し、それをグローバルシングルトンで管理するのはどうでしょうか？ これにより、コンポーネントツリーは大きな "ビュー" となり、どのコンポーネントもツリー内のどこにあっても状態にアクセスしたり、アクションをトリガーできます!

さらに、状態管理に関わる概念を定義、および分離し、あるルールを敷くことで、コードの構造と保守性を向上させます。

Vuex の背景にある基本的なアイディアは、[Flux](https://facebook.github.io/flux/docs/overview.html)、 [Redux](http://redux.js.org/) そして [The Elm Architecture](https://guide.elm-lang.org/architecture/)から影響を受けたものです。
他のパターンと異なり、Vuexは効率的な更新のために、Vue.jsの粒度の細かいリアクティビティシステムを利用するよう特別に調整された実装のライブラリです。

![vuex](./images/vuex.png)

### いつ、Vuexを使うべきでしょうか？

Vuex は、共有状態の管理に役立ちますが、さらに概念やボイラープレートのコストがかかります。これは、短期的生産性と長期的生産性のトレードオフです。

もし、あなたが大規模なSPAを構築することなく、Vuex を導入した場合、冗長で恐ろしいかんじになるかもしれません。そう感じることは全く普通です。もし、あなたのアプリがシンプルであれば、Vuex なしで問題ないでしょう。シンプルな [グローバル イベント パス](http://vuejs.org/guide/components.html#Non-Parent-Child-Communication) が必要なだけかもしれません。しかし、中規模から大規模のSPAを構築する場合は、Vue コンポーネント以外のどうやってうまく扱うか考える絶好の機会です。Vuex は自然な次のステップとなるでしょう。これは Redux の作者、Dan Abramov からの良い引用です:

> Flux ライブラリは眼鏡のようなものです: それらが必要になったときに知ることになります。